;;; Copyright (c) 2012 Yannick Drant, Matthieu Lagacherie, All Rights Reserved

(in-package :cl-cmaes)

(defun cmaes-test (lmbd dim)
  (cffi:with-foreign-objects ((ptr 'cmaes)
			      (xstart :double 2)
			      (stddev :double 2)
			      (funvals :pointer))
    (dotimes (i dim)
      (setf (cffi:mem-aref xstart :double i) 0.5d0)
      (setf (cffi:mem-aref stddev :double i) 0.5d0))
    (setf funvals (cmaes_init ptr dim xstart stddev 42 lmbd "outfile"))
    (format t "~A~%" (cmaes_sayhello ptr))
    (cmaes-readsignals ptr "signals.par")
    (format t "Termination ~a~%" (cmaes_testfortermination ptr))
    (loop for term = (cmaes_testfortermination ptr)
       while (not term) do
       (let ((pop (cmaes_samplepopulation ptr))
             (clambda (round (cmaes_get ptr "lambda"))))
         (format t "New iteration ~a ~a~%" pop clambda)
         (dotimes (l (round (cmaes_get ptr "popsize")))
           (let ((is-feasible t)
                 (val 0))
             (dotimes (d dim)
               (setf val (cffi:mem-aref (cffi:mem-aref pop :pointer l) :double d))
               (when (< val 1) (setf is-feasible ())))
             (cmaes-resamplesingle ptr l)))
         (dotimes (l clambda)
           (setf (cffi:mem-aref funvals :double l) (random 100d0)))
         (format t "PopSize ~a~%" (cmaes_get ptr "popsize"))
         (cmaes_updatedistribution ptr funvals)
         (cmaes_readsignals ptr "signals.par")
         ))
    (cmaes-exit ptr)
    ))

(defun cmaes-copy-individual (pop dim &optional (index -1))
  (let ((idv (make-array dim :element-type 'double-float)))
    (if (< index 0)
        (dotimes (i dim)
          (setf (aref idv i) (cffi:mem-aref pop :double i)))
        (dotimes (i dim)
          (setf (aref idv i) (cffi:mem-aref (cffi:mem-aref pop :pointer index) :double i))))
    idv))

(defun cmaes-print-individual (pop dim &optional (index -1) (sfx ""))
  (format t "Individual ~a:" (if (> index 0) index 0))
  (if (< index 0)
      (dotimes (i dim)
        (format t " ~,1f" (cffi:mem-aref pop :double i)))
      (dotimes (i dim)
        (format t " ~,1f" (cffi:mem-aref (cffi:mem-aref pop :pointer index) :double i))))
  (format t " ~a~%" sfx))

(defun cmaes-print-solution (y)
  (loop for i of-type fixnum from 0 below (array-dimension y 0) do
       (format t "~,1f" (aref y i)))
  (format t "~%"))

(defun cmaes-optimize (fn dim &key (lmbd 20) (filename "cmaes-opt.out") (seed (random 1000)))
  "Optimize the function fn of dimension dim with a lambda lmbd"
  (cffi:with-foreign-objects ((ptr 'cmaes)
			      (xstart :double dim)
			      (stddev :double dim)
			      (funvals :pointer))
    (dotimes (i dim)
      (setf (cffi:mem-aref xstart :double i) 0.5d0)
      (setf (cffi:mem-aref stddev :double i) 0.5d0))
    (setf funvals (cmaes_init ptr dim xstart stddev seed lmbd filename))
    (format t "~a~%" (cmaes_sayhello ptr))
    (loop for term = (cmaes_testfortermination ptr)
       while (cffi:null-pointer-p term) do
	 (let ((pop (cmaes_samplepopulation ptr))
	       (clambda (round (cmaes_get ptr "lambda"))))
	   (dotimes (l clambda)
	     (let ((idv (cmaes-copy-individual pop dim l)))
	       (setf (cffi:mem-aref funvals :double l) (funcall fn idv)))
                                        ;	     (cmaes-print-individual pop dim l (format nil " value ~a" (mem-aref funvals :double l)))
	     )
	   (cmaes_updatedistribution ptr funvals)))
    (setf funvals (cmaes_getptr ptr "xbestever"))
    (cmaes-print-individual funvals dim -1 (format nil " value ~,1f"
                                                   (funcall fn (cmaes-copy-individual funvals dim))))
    (format t "Stop: ~a~%" (cffi:foreign-string-to-lisp (cmaes_testfortermination ptr)))
    (cmaes_exit ptr)
    ))

(defmacro with-gensyms (syms &body body)
  `(let ,(mapcar #'(lambda (s) `(,s (gensym))) syms) ,@body))

(defmacro with-cmaes ((x y dim &key (lmbd 20) (filename "cmaes-opt.out") (seed (random 1000))
                         (maxiter 200) (start 0.5) (stdev 0.5))
                      &key computeall compute post)
  "Macro that optimize a function"
  (with-gensyms (xstart xstd ptr funvals pop term clambda row col is-feasible floop fval)
    `(cffi:with-foreign-objects ((,ptr 'cmaes)
                                 (,xstart :double ,dim)
                                 (,xstd :double ,dim)
                                 (,funvals :pointer))
       (cmaes_setparam ,ptr "maxgen" (coerce ,maxiter 'double-float))
       (let ((,x (make-array ,(if (consp compute) dim `(list ,lmbd ,dim)) :element-type 'double-float)))
         (dotimes (,row ,dim)
           (setf (cffi:mem-aref ,xstart :double ,row) (coerce ,start 'double-float))
           (setf (cffi:mem-aref ,xstd :double ,row) (coerce ,stdev 'double-float)))
         (setf ,funvals (cmaes_init ,ptr ,dim ,xstart ,xstd ,seed ,lmbd ,filename))
         (loop for ,term = (cmaes_testfortermination ,ptr)
            while (cffi:null-pointer-p ,term) do
            (let* ((,pop (cmaes_samplepopulation ,ptr))
                   (,clambda (round (cmaes_get ,ptr "lambda")))
                   (,y (make-array ,clambda :element-type 'double-float)))
              (dotimes (,row ,clambda)
                (loop for ,is-feasible = (block ,floop
                                           (dotimes (,col ,dim)
                                             (let ((,fval (cffi:mem-aref (cffi:mem-aref ,pop :pointer ,row) :double ,col)))
                                               (when (or (< ,fval 0) (> ,fval 1))
                                                 (return-from ,floop nil))))
                                           t)
                   while (not ,is-feasible) do (cmaes_resamplesingle ,ptr ,row)))
              
              ,(if (consp compute)
                   `(dotimes (,row ,clambda)
                      (dotimes (,col ,dim)
                        (setf (aref ,x ,col) (cffi:mem-aref (cffi:mem-aref ,pop :pointer ,row) :double ,col)))
                      (setf (cffi:mem-aref ,funvals :double ,row) (,@compute)))
                   `(progn (dotimes (,row ,clambda)
                             (dotimes (,col ,dim)
                               (setf (aref ,x ,row ,col)
                                     (cffi:mem-aref (cffi:mem-aref ,pop :pointer ,row)
                                                    :double ,col))))
                           (,@computeall)
                           (dotimes (,row ,clambda)
                             (setf (cffi:mem-aref ,funvals :double ,row) (aref ,y ,row)))))
              (cmaes_updatedistribution ,ptr ,funvals)
              (cmaes_readsignals ,ptr "signals.par")))
         (let ((,y (make-array ,dim :element-type 'double-float)))
           (setf ,funvals (cmaes_getptr ,ptr "xbestever"))
           (dotimes (,row ,dim)
             (setf (aref ,y ,row) (cffi:mem-aref ,funvals :double ,row)))
           (,@post)
                                        ;           (format t "Stop: ~a~%" (cffi:foreign-string-to-lisp (cmaes_testfortermination ,ptr)))
           (cmaes_exit ,ptr))))))

(defun test-with-cmaes ()
  (with-cmaes (xsol funv 13)
    :compute (cmaes-cigtab xsol) 
    :post (format t "Post~a~%" funv)))

(defun cmaes-cigtab (x)
  (labels ((cigtab (acc index)
             (if (= index 1)
                 (+ acc
                    (* 10000d0 (expt (aref x 1) 2.0))
                    (* 0.0001d0 (expt (aref x 0) 2.0)))
                 (cigtab (+ acc (expt (aref x index) 2.0)) (1- index)))))
    (if (< (array-dimension x 0) 2)
        (error "CIGTAB function needs at least 2 dimensions")
        (cigtab 0 (1- (array-dimension x 0))))))

(lisp-unit:define-test test-cmaes_init
  (let ((lmbd 10) (dim 2))
    (cffi:with-foreign-objects ((ptr 'cmaes)
                                (xstart :double dim)
                                (stddev :double dim)
                                (funvals :pointer))
      (dotimes (i dim)
        (setf (cffi:mem-aref xstart :double i) 0.5d0)
        (setf (cffi:mem-aref stddev :double i) 0.5d0))
      (setf funvals (cmaes_init ptr 2 xstart stddev 42 lmbd "outfile"))
      (assert-true (= (cmaes_get ptr "popsize") lmbd))
      (assert-true (= (cmaes_get ptr "N") dim)))))

(lisp-unit:define-test test-cmaes-cigtab
  (assert-true (= (cmaes-cigtab (make-array 3 :element-type 'double-float :initial-contents '(1.0d0 2.0d0 3.0d0))) 40009.0001d0))
  (assert-true (= (cmaes-cigtab (make-array 4 :element-type 'double-float :initial-contents '(1.0d0 2.0d0 3.0d0 10.0d0))) 40109.0001d0))
  (assert-true (= (cmaes-cigtab (make-array 2 :element-type 'double-float :initial-contents '(1.0d0 2.0d0))) 40000.0001d0)))

(defun test-cmaes-optimize-cigtab ()
  (cmaes-optimize #'cmaes-cigtab 23 :lmbd 13))

(defun test-cmaes-optimize-cigtab2 ()
  (with-cmaes (x y 23 :lmbd 13 :maxiter 100)
    :compute (cmaes-cigtab x)
    :post (format t "Final value ~a: ~,1f~%" (cmaes-print-solution y) (cmaes-cigtab y))))
